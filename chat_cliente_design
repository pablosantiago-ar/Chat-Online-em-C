#include<stdio.h>
    
void limpar_tela(){
    system("cls");
}

void exibir_menu_emoticons() {
    printf("\nSelecione um emoticon:\n");
    printf("1. :-) (sorriso)\n");
    printf("2. :-( (triste)\n");
    printf("3. ;-) (piscada)\n");
    printf("4. :-D (riso)\n");
    printf("5. :-O (surpreso)\n");
    printf("6. :-P (lingua)\n");
    printf("7. nenhum\n");
    printf("Escolha uma opção (1 a 7): ");
}

char* obter_emoticon(int escolha) {
    switch (escolha) {
        case 1: return ":-)";
        case 2: return ":-(";
        case 3: return ";-)";
        case 4: return ":-D";
        case 5: return ":-O";
        case 6: return ":-P";
        default: return "";
    }
}

void mandarEmoji(){
    char mensagem[100];
    char buffer[100];
    char *emoticon = "";
    int escolha_emoticon;

    while(1) {
        printf("Digite '/emoticons' para selecionar um emoticon, ou digite sua mensagem: ");
        fflush(stdout);
        fgets(buffer, sizeof(buffer), stdin);
        buffer[strcspn(buffer, "\n")] = 0;

        if(strcmp(buffer, "/emoticons") == 0) {
            exibir_menu_emoticons();
            scanf("%d", &escolha_emoticon);
            while(getchar() != '\n');
            emoticon = obter_emoticon(escolha_emoticon);
            printf("Emoticon selecionado: %s\n", emoticon);
        } else {
            strcpy(mensagem, buffer);
            if (strlen(emoticon) > 0) {
                strcat(mensagem, " ");
                strcat(mensagem, emoticon);
            }
            
            printf("Você: %s\n", mensagem);
            emoticon = "";
        }
    }
}
int menu(){
    int op;

    printf("MENU\n");
    printf("O que voce deseja fazer?\n");
    printf("1- Entrar no chat\n");
    printf("2- Passo a passo\n");
    
    scanf("%d", &op);
    return op;
}
int main(){
        int op;
        int opp;
        op = menu();

        if(op==1){
            SOCKET clienteSockfd = clientconfig();
            Cliente(clienteSockfd);
        }
        else if(op==2){
            printf("passo a passo\n");
            printf("1- para apagar o histórico de mensagens\n");
            printf("2- para limpar o chat\n");
            printf("3- para mandar emoji\n");
            printf("4- para fechar o chat\n");

            scanf("%d",&opp);

            if(opp==1){
                printf("Para apagar o historico de mensagens digite o comando: APAGAR_HISTORICO\n\n");
                menu();
            }
            else if(opp==2){
                printf("Para limpar o chat digite o comando:  limpar_tela\n\n");
                menu();
            }
            else if(opp==3){
                printf("Para mandar emoji digite o comando: mandarEmoji\n\n");
                menu();
            }
            else if(opp==4){
                printf("Para fechar o chat digite o comando: /quit\n\n");
                menu();
            }            
        }
        return 0;











===================================================================================

#include <winsock2.h>
#include <windows.h>
#include <ws2tcpip.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#pragma comment(lib, "Ws2_32.lib")

#define TAMANHO_BUFFER 1024

// Função para zerar uma string, substituindo caracteres por espaços
void zerar_string(char string[]) {
    int i;
    int cont = strlen(string);
    for (i = 0; i < cont; i++) {
        string[i] = ' ';
    }
}

void imprimeicone(char* n){
	char str[1000];
    sprintf(str,"powershell.exe -Command \"[System.Char]::ConvertFromUtf32([System.Convert]::toInt32('%s',16))\"", n);
	system(str);
}

//Menu que exibe as opções de emojis
void exibir_menu_emoticons() {
    char str[10];
    // printf("\nSelecione um emoticon:\n");
    // printf("1. :-) (sorriso)\n");
    // printf("2. :-( (triste)\n");
    // printf("3. ;-) (piscada)\n");
    // printf("4. :-D (riso)\n");
    // printf("5. :-O (surpreso)\n");
    // printf("6. :-P (lingua)\n");
    // printf("7. nenhum\n");
    // printf("Escolha uma alternativa (1 a 7): ");
    strcpy(str, "1F600");
    printf("1.");
    imprimeicone(str);
    printf("\n");
    zerar_string(str);
    strcpy(str, "1F614");
    printf("2.");
    imprimeicone(str);
    printf("\n");
    zerar_string(str);
    strcpy(str, "1F61C");
    printf("3.");
	imprimeicone(str);
    printf("\n");
    zerar_string(str);
    strcpy(str, "1F609");
    printf("4.");
	imprimeicone(str);
    printf("\n");
    zerar_string(str);    
    strcpy(str, "1F601");
    printf("5.");
	imprimeicone(str);
    printf("\n");
    zerar_string(str);
    strcpy(str, "1F636");
    printf("6.");
	imprimeicone(str);
    printf("\n");
    zerar_string(str);
    strcpy(str, "1F61B");
    printf("7.");
	imprimeicone(str);
    printf("\n");
    zerar_string(str);
}

//Retorna no chat o emoji escolhido
char* obter_emoticon(int escolha) {
    switch (escolha) {
        case 1: return ":-)";
        case 2: return ":-(";
        case 3: return ";-)";
        case 4: return ":-D";
        case 5: return ":-O";
        case 6: return ":-P";
        default: return "Nao achei um emoji :(";
    }
}

// Função para configurar a conexão do cliente
SOCKET clientconfig() {
    SOCKET clienteSockfd;
    struct sockaddr_in serv_addr;
    WSADATA wsaData;
    int result;

    // Inicializa Winsock
    result = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (result != 0) {
        printf("WSAStartup failed: %d\n", result);
        exit(1);
    }

    // Cria o socket do cliente
    clienteSockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (clienteSockfd == INVALID_SOCKET) {
        printf("Erro no Socket: %d\n", WSAGetLastError());
        WSACleanup();
        exit(1);
    }
    
    // Configura a estrutura do endereço do servidor
    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1"); // IP do servidor (localhost)
    serv_addr.sin_port = htons(8888); // Porta do servidor

    // Conecta ao servidor
    if (connect(clienteSockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) == SOCKET_ERROR) {
        printf("Erro no Connect: %d\n", WSAGetLastError());
        closesocket(clienteSockfd);
        WSACleanup();
        exit(1);
    }

    return clienteSockfd;
}

// Função principal do cliente
void Cliente(SOCKET clienteSockfd) {
    char msg[TAMANHO_BUFFER];
    char nome[30];
    char *emoticon = "";
    int escolha_emoticon;
    
    // Receber e enviar o nome do cliente
    printf("Digite seu nome: ");
    fgets(nome, sizeof(nome), stdin);
    nome[strcspn(nome, "\n")] = '\0';  // Remove a nova linha no final

    // Enviar nome para o servidor
    send(clienteSockfd, nome, strlen(nome), 0);

    while (1) {
        // Receber e exibir mensagens do servidor
        int bytesReceived = recv(clienteSockfd, msg, sizeof(msg) - 1, 0);
        if (bytesReceived > 0) {
            msg[bytesReceived] = '\0';
            printf("%s", msg);
        }

        // Enviar mensagens para o servidor
        printf("%s: ", nome);
        zerar_string(msg);
        fgets(msg, sizeof(msg), stdin);
        msg[strcspn(msg, "\n")] = '\0';  // Remove a nova linha no final

        if (strcmp(msg, "APAGAR_HISTORICO") == 0) {
            // Enviar comando para apagar o histórico
            send(clienteSockfd, msg, strlen(msg), 0);
        } else if (strcmp(msg, "quit") == 0) {
            // Enviar comando de desconexão
            send(clienteSockfd, msg, strlen(msg), 0);
            break;

        } else if(strcmp(msg, "/emoticons") == 0){
            exibir_menu_emoticons();
            scanf("%d", &escolha_emoticon);
            getchar();
            emoticon = obter_emoticon(escolha_emoticon);
            printf("%s: %s\n",nome, emoticon);

            send(clienteSockfd, emoticon, strlen(emoticon), 0);

        } else {
            // Enviar mensagem normal
            send(clienteSockfd, msg, strlen(msg), 0);
        }
    }
    
    // Encerra o socket
    closesocket(clienteSockfd);
    WSACleanup();
}

int main() {
    // Chama a função do cliente passando o descritor
    SOCKET clienteSockfd = clientconfig();
    Cliente(clienteSockfd);
    return 0;
}




    }
    
